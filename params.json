{
  "name": "Zork-team-6",
  "tagline": "The big project for CPSC 240",
  "body": "# Zork-Team-6\r\nThe big project for CPSC 240\r\n\r\n\r\n/**\r\n * Abstract class for multiple command types\r\n * @author Scott, Ryan, David\r\n * @version Group project 2\r\n */\r\nabstract class Command {\r\n\r\n    abstract String execute();\r\n\r\n}\r\n\r\n/**\r\n * Takes commands from user input and determines what kind of command it is, then calls an execution method for that particular command.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n */\r\npublic class CommandFactory {\r\n\r\n    private static CommandFactory theInstance;\r\n    public static List<String> MOVEMENT_COMMANDS = \r\n        Arrays.asList(\"n\",\"w\",\"e\",\"s\",\"u\",\"d\" );\r\n    /**\r\n     * Instance method for the singleton class\r\n     * @return CommandFactory - the instance of one command\r\n     */\r\n    public static synchronized CommandFactory instance() {\r\n        if (theInstance == null) {\r\n            theInstance = new CommandFactory();\r\n        }\r\n        return theInstance;\r\n    }\r\n\r\n    private CommandFactory() {\r\n    }\r\n\r\n    /**\r\n     * Takes an input from the user and determines what kind of command it is, then returns that command\r\n     * @param String the command input\r\n     * @return SaveCommand - command to save the game\r\n     * @return TakeCommand - command to pick up an item\r\n     * @return DropCommand - command to remove an item from the player’s inventory\r\n     * @return InventoryCommand - displays the player’s inventory\r\n     * @return MovementCommand - command to move to a different room\r\n     * @return ItemSpecificCommand - command to perform an action on an item\r\n     * @return UnknownCommand - unrecognized command\r\n     */\r\n    public Command parse(String command) {\r\n        String parts[] = command.split(\" \");\r\n        String verb = parts[0];\r\n        String noun = parts.length >= 2 ? parts[1] : \"\";\r\n        if (verb.equals(\"save\")) {\r\n            return new SaveCommand(noun);\r\n        }\r\n        if (verb.equals(\"take\")) {\r\n            return new TakeCommand(noun);\r\n        }\r\n        if (verb.equals(\"drop\")) {\r\n            return new DropCommand(noun);\r\n        }\r\n        if (verb.equals(\"i\") || verb.equals(\"inventory\")) {\r\n            return new InventoryCommand();\r\n        }\r\n        if (MOVEMENT_COMMANDS.contains(verb)) {\r\n            return new MovementCommand(verb);\r\n        }\r\n        if (parts.length == 2) {\r\n            return new ItemSpecificCommand(verb, noun);\r\n        }\r\n        return new UnknownCommand(command);\r\n    }\r\n}\r\n\r\n/**\r\n * Command for transforming multiple items into a different item\r\n * @author David, Scott, Ryan\r\n * @version Group Project 2\r\n */\r\npublic class CraftCommand extends Command {\r\n\r\n\tpublic CraftCommand(){\r\n\t}\r\n\t\r\n        /**\r\n         * Checks to see if the player has both the specified items\r\n         * removes them from the player’s inventory and adds the crafted item if they are both present\r\n         * notifies the player that they do not have the necessary items if they are not\r\n         * @return String - affirmation that the items have been crafted\r\n         * @return String - Notice that the player does not have the necessary items\r\n         */\r\n\r\n\t@Override\r\n\tString execute() {\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n\r\n/** \r\n * command to remove an item from the player’s inventory\r\n * @author David, Scott, Ryan\r\n * @version Group Project 2\r\n */\r\n\r\nclass DropCommand extends Command {\r\n\r\n    private String itemName;\r\n\r\n    DropCommand(String itemName) {\r\n        this.itemName = itemName;\r\n    }\r\n    /**\r\n     * Checks to see if the specified item is in the players inventory\r\n     * removes it if it is, prints a message stating they do not have the item if it is not\r\n     * @return String - affirmation that the item was dropped\r\n     * @return String - Notice that the player does not have the item\r\n     */\r\n    public String execute() {\r\n        if (itemName == null || itemName.trim().length() == 0) {\r\n            return \"Drop what?\\n\";\r\n        }\r\n        try {\r\n            Item theItem = GameState.instance().getItemFromInventoryNamed(\r\n                itemName);\r\n            GameState.instance().removeFromInventory(theItem);\r\n            GameState.instance().getAdventurersCurrentRoom().add(theItem);\r\n            return itemName + \" dropped.\\n\";\r\n        } catch (Item.NoItemException e) {\r\n            return \"You don't have a \" + itemName + \".\\n\";\r\n        }\r\n    }\r\n}\r\n\r\nimport java.util.Hashtable;\r\nimport java.util.Scanner;\r\nimport java.io.IOException;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.PrintWriter;\r\n\r\npublic class Dungeon {\r\n\r\n    public static class IllegalDungeonFormatException extends Exception {\r\n        public IllegalDungeonFormatException(String e) {\r\n            super(e);\r\n        }\r\n    }\r\n\r\n    // Variables relating to both dungeon file and game state storage.\r\n    public static String TOP_LEVEL_DELIM = \"===\";\r\n    public static String SECOND_LEVEL_DELIM = \"---\";\r\n\r\n    // Variables relating to dungeon file (.bork) storage.\r\n    public static String ROOMS_MARKER = \"Rooms:\";\r\n    public static String EXITS_MARKER = \"Exits:\";\r\n    public static String ITEMS_MARKER = \"Items:\";\r\n    \r\n    // Variables relating to game state (.sav) storage.\r\n    static String FILENAME_LEADER = \"Dungeon file: \";\r\n    static String ROOM_STATES_MARKER = \"Room states:\";\r\n\r\n    private String name;\r\n    private Room entry;\r\n    private Hashtable<String,Room> rooms;\r\n    private Hashtable<String,Item> items;\r\n    private String filename;\r\n\r\n    Dungeon(String name, Room entry) {\r\n        init();\r\n        this.filename = null;    // null indicates not hydrated from file.\r\n        this.name = name;\r\n        this.entry = entry;\r\n        rooms = new Hashtable<String,Room>();\r\n    }\r\n\r\n    /**\r\n     * Read from the .bork filename passed, and instantiate a Dungeon object\r\n     * based on it.\r\n     */\r\n    public Dungeon(String filename) throws FileNotFoundException, \r\n        IllegalDungeonFormatException {\r\n\r\n        this(filename, true);\r\n    }\r\n\r\n    /**\r\n     * Read from the .bork filename passed, and instantiate a Dungeon object\r\n     * based on it, including (possibly) the items in their original locations.\r\n     */\r\n    public Dungeon(String filename, boolean initState) \r\n        throws FileNotFoundException, IllegalDungeonFormatException {\r\n\r\n        init();\r\n        this.filename = filename;\r\n\r\n        Scanner s = new Scanner(new FileReader(filename));\r\n        name = s.nextLine();\r\n\r\n        s.nextLine();   // Throw away version indicator.\r\n\r\n        // Throw away delimiter.\r\n        if (!s.nextLine().equals(TOP_LEVEL_DELIM)) {\r\n            throw new IllegalDungeonFormatException(\"No '\" +\r\n                TOP_LEVEL_DELIM + \"' after version indicator.\");\r\n        }\r\n\r\n        // Throw away Items starter.\r\n        if (!s.nextLine().equals(ITEMS_MARKER)) {\r\n            throw new IllegalDungeonFormatException(\"No '\" +\r\n                ITEMS_MARKER + \"' line where expected.\");\r\n        }\r\n\r\n        try {\r\n            // Instantiate items.\r\n            while (true) {\r\n                add(new Item(s));\r\n            }\r\n        } catch (Item.NoItemException e) {  /* end of items */ }\r\n\r\n        // Throw away Rooms starter.\r\n        if (!s.nextLine().equals(ROOMS_MARKER)) {\r\n            throw new IllegalDungeonFormatException(\"No '\" +\r\n                ROOMS_MARKER + \"' line where expected.\");\r\n        }\r\n\r\n        try {\r\n            // Instantiate and add first room (the entry).\r\n            entry = new Room(s, this, initState);\r\n            add(entry);\r\n\r\n            // Instantiate and add other rooms.\r\n            while (true) {\r\n                add(new Room(s, this, initState));\r\n            }\r\n        } catch (Room.NoRoomException e) {  /* end of rooms */ }\r\n\r\n        // Throw away Exits starter.\r\n        if (!s.nextLine().equals(EXITS_MARKER)) {\r\n            throw new IllegalDungeonFormatException(\"No '\" +\r\n                EXITS_MARKER + \"' line where expected.\");\r\n        }\r\n\r\n        try {\r\n            // Instantiate exits.\r\n            while (true) {\r\n                Exit exit = new Exit(s, this);\r\n            }\r\n        } catch (Exit.NoExitException e) {  /* end of exits */ }\r\n\r\n        s.close();\r\n    }\r\n    \r\n    // Common object initialization tasks, regardless of which constructor\r\n    // is used.\r\n    private void init() {\r\n        rooms = new Hashtable<String,Room>();\r\n        items = new Hashtable<String,Item>();\r\n    }\r\n\r\n    /*\r\n     * Store the current (changeable) state of this dungeon to the writer\r\n     * passed.\r\n     */\r\n    void storeState(PrintWriter w) throws IOException {\r\n        w.println(FILENAME_LEADER + getFilename());\r\n        w.println(ROOM_STATES_MARKER);\r\n        for (Room room : rooms.values()) {\r\n            room.storeState(w);\r\n        }\r\n        w.println(TOP_LEVEL_DELIM);\r\n    }\r\n\r\n    /*\r\n     * Restore the (changeable) state of this dungeon to that reflected in the\r\n     * reader passed.\r\n     */\r\n    void restoreState(Scanner s) throws GameState.IllegalSaveFormatException {\r\n\r\n        // Note: the filename has already been read at this point.\r\n        \r\n        if (!s.nextLine().equals(ROOM_STATES_MARKER)) {\r\n            throw new GameState.IllegalSaveFormatException(\"No '\" +\r\n                ROOM_STATES_MARKER + \"' after dungeon filename in save file.\");\r\n        }\r\n\r\n        String roomName = s.nextLine();\r\n        while (!roomName.equals(TOP_LEVEL_DELIM)) {\r\n            getRoom(roomName.substring(0,roomName.length()-1)).\r\n                restoreState(s, this);\r\n            roomName = s.nextLine();\r\n        }\r\n    }\r\n\r\n    public Room getEntry() { return entry; }\r\n    public String getName() { return name; }\r\n    public String getFilename() { return filename; }\r\n    public void add(Room room) { rooms.put(room.getTitle(),room); }\r\n    public void add(Item item) { items.put(item.getPrimaryName(),item); }\r\n\r\n    public Room getRoom(String roomTitle) {\r\n        return rooms.get(roomTitle);\r\n    }\r\n\r\n    /**\r\n     * Get the Item object whose primary name is passed. This has nothing to\r\n     * do with where the Adventurer might be, or what's in his/her inventory,\r\n     * etc.\r\n     */\r\n    public Item getItem(String primaryItemName) throws Item.NoItemException {\r\n        \r\n        if (items.get(primaryItemName) == null) {\r\n            throw new Item.NoItemException();\r\n        }\r\n        return items.get(primaryItemName);\r\n    }\r\n}\r\n\r\npublic class Event {\r\n\r\n\tprivate String eventName;\r\n\t\r\n\tpublic Event(String eventName){\r\n\t}\r\n\t\r\n\tString execute(){\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\tString determineType(){\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\tprivate void deathEvent(){}\r\n\t\r\n\tprivate void scoreEvent(){}\r\n\t\r\n\tprivate void woundEvent(){}\r\n\t\r\n\tprivate void teleportEvent(){}\r\n\t\r\n\tprivate void disappearEvent(){}\r\n\t\r\n\tprivate void transformEvent(){}\r\n\t\r\n\tprivate void winEvent(){}\r\n\t\r\n\t}\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Exit {\r\n\r\n    class NoExitException extends Exception {}\r\n\r\n    private String dir;\r\n    private Room src, dest;\r\n\r\n    Exit(String dir, Room src, Room dest) {\r\n        init();\r\n        this.dir = dir;\r\n        this.src = src;\r\n        this.dest = dest;\r\n        src.addExit(this);\r\n    }\r\n\r\n    /** Given a Scanner object positioned at the beginning of an \"exit\" file\r\n        entry, read and return an Exit object representing it. \r\n        @param d The dungeon that contains this exit (so that Room objects \r\n        may be obtained.)\r\n        @throws NoExitException The reader object is not positioned at the\r\n        start of an exit entry. A side effect of this is the reader's cursor\r\n        is now positioned one line past where it was.\r\n        @throws IllegalDungeonFormatException A structural problem with the\r\n        dungeon file itself, detected when trying to read this room.\r\n     */\r\n    Exit(Scanner s, Dungeon d) throws NoExitException,\r\n        Dungeon.IllegalDungeonFormatException {\r\n\r\n        init();\r\n        String srcTitle = s.nextLine();\r\n        if (srcTitle.equals(Dungeon.TOP_LEVEL_DELIM)) {\r\n            throw new NoExitException();\r\n        }\r\n        src = d.getRoom(srcTitle);\r\n        dir = s.nextLine();\r\n        dest = d.getRoom(s.nextLine());\r\n        \r\n        // I'm an Exit object. Great. Add me as an exit to my source Room too,\r\n        // though.\r\n        src.addExit(this);\r\n\r\n        // throw away delimiter\r\n        if (!s.nextLine().equals(Dungeon.SECOND_LEVEL_DELIM)) {\r\n            throw new Dungeon.IllegalDungeonFormatException(\"No '\" +\r\n                Dungeon.SECOND_LEVEL_DELIM + \"' after exit.\");\r\n        }\r\n    }\r\n\r\n    // Common object initialization tasks.\r\n    private void init() {\r\n    }\r\n\r\n    String describe() {\r\n        return \"You can go \" + dir + \" to \" + dest.getTitle() + \".\";\r\n    }\r\n\r\n    String getDir() { return dir; }\r\n    Room getSrc() { return src; }\r\n    Room getDest() { return dest; }\r\n}\r\n\r\nimport java.util.Scanner;\r\nimport java.util.ArrayList;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.PrintWriter;\r\n\r\npublic class GameState {\r\n\r\n    public static class IllegalSaveFormatException extends Exception {\r\n        public IllegalSaveFormatException(String e) {\r\n            super(e);\r\n        }\r\n    }\r\n\r\n    static String DEFAULT_SAVE_FILE = \"bork_save\";\r\n    static String SAVE_FILE_EXTENSION = \".sav\";\r\n    static String SAVE_FILE_VERSION = \"Bork v3.0 save data\";\r\n\r\n    static String ADVENTURER_MARKER = \"Adventurer:\";\r\n    static String CURRENT_ROOM_LEADER = \"Current room: \";\r\n    static String INVENTORY_LEADER = \"Inventory: \";\r\n\r\n    private static GameState theInstance;\r\n    private Dungeon dungeon;\r\n    private ArrayList<Item> inventory;\r\n    private Room adventurersCurrentRoom;\r\n\r\n    static synchronized GameState instance() {\r\n        if (theInstance == null) {\r\n            theInstance = new GameState();\r\n        }\r\n        return theInstance;\r\n    }\r\n\r\n    private GameState() {\r\n        inventory = new ArrayList<Item>();\r\n    }\r\n\r\n    void restore(String filename) throws FileNotFoundException,\r\n        IllegalSaveFormatException, Dungeon.IllegalDungeonFormatException {\r\n\r\n        Scanner s = new Scanner(new FileReader(filename));\r\n\r\n        if (!s.nextLine().equals(SAVE_FILE_VERSION)) {\r\n            throw new IllegalSaveFormatException(\"Save file not compatible.\");\r\n        }\r\n\r\n        String dungeonFileLine = s.nextLine();\r\n\r\n        if (!dungeonFileLine.startsWith(Dungeon.FILENAME_LEADER)) {\r\n            throw new IllegalSaveFormatException(\"No '\" +\r\n                Dungeon.FILENAME_LEADER + \r\n                \"' after version indicator.\");\r\n        }\r\n\r\n        dungeon = new Dungeon(dungeonFileLine.substring(\r\n            Dungeon.FILENAME_LEADER.length()), false);\r\n        dungeon.restoreState(s);\r\n\r\n        s.nextLine();  // Throw away \"Adventurer:\".\r\n        String currentRoomLine = s.nextLine();\r\n        adventurersCurrentRoom = dungeon.getRoom(\r\n            currentRoomLine.substring(CURRENT_ROOM_LEADER.length()));\r\n        if (s.hasNext()) {\r\n            String inventoryList = s.nextLine().substring(\r\n                INVENTORY_LEADER.length());\r\n            String[] inventoryItems = inventoryList.split(\",\");\r\n            for (String itemName : inventoryItems) {\r\n                try {\r\n                    addToInventory(dungeon.getItem(itemName));\r\n                } catch (Item.NoItemException e) {\r\n                    throw new IllegalSaveFormatException(\"No such item '\" +\r\n                        itemName + \"'\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void store() throws IOException {\r\n        store(DEFAULT_SAVE_FILE);\r\n    }\r\n\r\n    void store(String saveName) throws IOException {\r\n        String filename = saveName + SAVE_FILE_EXTENSION;\r\n        PrintWriter w = new PrintWriter(new FileWriter(filename));\r\n        w.println(SAVE_FILE_VERSION);\r\n        dungeon.storeState(w);\r\n        w.println(ADVENTURER_MARKER);\r\n        w.println(CURRENT_ROOM_LEADER + adventurersCurrentRoom.getTitle());\r\n        if (inventory.size() > 0) {\r\n            w.print(INVENTORY_LEADER);\r\n            for (int i=0; i<inventory.size()-1; i++) {\r\n                w.print(inventory.get(i).getPrimaryName() + \",\");\r\n            }\r\n            w.println(inventory.get(inventory.size()-1).getPrimaryName());\r\n        }\r\n        w.close();\r\n    }\r\n\r\n    void initialize(Dungeon dungeon) {\r\n        this.dungeon = dungeon;\r\n        adventurersCurrentRoom = dungeon.getEntry();\r\n    }\r\n\r\n    ArrayList<String> getInventoryNames() {\r\n        ArrayList<String> names = new ArrayList<String>();\r\n        for (Item item : inventory) {\r\n            names.add(item.getPrimaryName());\r\n        }\r\n        return names;\r\n    }\r\n\r\n    void addToInventory(Item item) /* throws TooHeavyException */ {\r\n        inventory.add(item);\r\n    }\r\n\r\n    void removeFromInventory(Item item) {\r\n        inventory.remove(item);\r\n    }\r\n\r\n    Item getItemInVicinityNamed(String name) throws Item.NoItemException {\r\n\r\n        // First, check inventory.\r\n        for (Item item : inventory) {\r\n            if (item.goesBy(name)) {\r\n                return item;\r\n            }\r\n        }\r\n\r\n        // Next, check room contents.\r\n        for (Item item : adventurersCurrentRoom.getContents()) {\r\n            if (item.goesBy(name)) {\r\n                return item;\r\n            }\r\n        }\r\n\r\n        throw new Item.NoItemException();\r\n    }\r\n\r\n    Item getItemFromInventoryNamed(String name) throws Item.NoItemException {\r\n\r\n        for (Item item : inventory) {\r\n            if (item.goesBy(name)) {\r\n                return item;\r\n            }\r\n        }\r\n        throw new Item.NoItemException();\r\n    }\r\n\r\n    Room getAdventurersCurrentRoom() {\r\n        return adventurersCurrentRoom;\r\n    }\r\n\r\n    void setAdventurersCurrentRoom(Room room) {\r\n        adventurersCurrentRoom = room;\r\n    }\r\n\r\n    Dungeon getDungeon() {\r\n        return dungeon;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Displays current health of the user in a description instead of a point value.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n *\r\n */\r\npublic class HealthCommand extends Command{\r\n\r\n\tHealthCommand(){\r\n\t}\r\n\t\r\n\t@Override\r\n\t/**\r\n\t * Checks to see players current health in GameState, chooses a description appropriate for point value\r\n\t * returns a String of that description\r\n\t * @return String - Description of players current health\r\n\t */\r\n\tString execute() {\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * Updated to be able to discern version of bork/save and pass off appropriately.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n *\r\n */\r\npublic class Interpreter {\r\n\r\n    private static GameState state; // not strictly necessary; GameState is \r\n                                    // singleton\r\n\r\n    public static String USAGE_MSG = \r\n        \"Usage: Interpreter borkFile.bork|saveFile.sav.\";\r\n\r\n    /**\r\n     * Discerns file type, and acts based on version of bork/save file, disabling certain classes/methods\r\n     * based on the file version.\r\n     * @param args\r\n     */\r\n    public static void main(String args[]) {\r\n\r\n        if (args.length < 1) {\r\n            System.err.println(USAGE_MSG);\r\n            System.exit(1);\r\n        }\r\n\r\n        String command;\r\n        Scanner commandLine = new Scanner(System.in);\r\n\r\n        try {\r\n            state = GameState.instance();\r\n            if (args[0].endsWith(\".bork\")) {\r\n                state.initialize(new Dungeon(args[0]));\r\n                System.out.println(\"\\nWelcome to \" + \r\n                    state.getDungeon().getName() + \"!\");\r\n            } else if (args[0].endsWith(\".sav\")) {\r\n                state.restore(args[0]);\r\n                System.out.println(\"\\nWelcome back to \" + \r\n                    state.getDungeon().getName() + \"!\");\r\n            } else {\r\n                System.err.println(USAGE_MSG);\r\n                System.exit(2);\r\n            }\r\n\r\n            System.out.print(\"\\n\" + \r\n                state.getAdventurersCurrentRoom().describe() + \"\\n\");\r\n\r\n            command = promptUser(commandLine);\r\n\r\n            while (!command.equals(\"q\")) {\r\n\r\n                System.out.print(\r\n                    CommandFactory.instance().parse(command).execute());\r\n\r\n                command = promptUser(commandLine);\r\n            }\r\n\r\n            System.out.println(\"Bye!\");\r\n\r\n        } catch(Exception e) { \r\n            e.printStackTrace(); \r\n        }\r\n    }\r\n\r\n    private static String promptUser(Scanner commandLine) {\r\n\r\n        System.out.print(\"> \");\r\n        return commandLine.nextLine();\r\n    }\r\n\r\n}\r\n\r\nimport java.util.ArrayList;\r\n\r\nclass InventoryCommand extends Command {\r\n\r\n    InventoryCommand() {\r\n    }\r\n\r\n    public String execute() {\r\n        ArrayList<String> names = GameState.instance().getInventoryNames();\r\n        if (names.size() == 0) {\r\n            return \"You are empty-handed.\\n\";\r\n        }\r\n        String retval = \"You are carrying:\\n\";\r\n        for (String itemName : names) {\r\n            retval += \"   A \" + itemName + \"\\n\";\r\n        }\r\n        return retval;\r\n    }\r\n}\r\n\r\n/**\r\n * Updated to read Point values and event hashtables associated with each item, as well as getting\r\n * those point values and saving them.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n */\r\nimport java.util.Scanner;\r\nimport java.util.Hashtable;\r\n\r\npublic class Item {\r\n\r\n    static class NoItemException extends Exception {}\r\n\r\n    private String primaryName;\r\n    private int weight;\r\n    private Hashtable<String,String> messages;\r\n    private int itemPoints;\r\n    private Hashtable events;\r\n    \r\n    /**\r\n     * Updated to read new line for item point value, and a separate section for events associated\r\n     * with each item, and the actions that trigger them - Triggered by ItemSpecific Command.\r\n     * @param s\r\n     * @throws NoItemException\r\n     * @throws Dungeon.IllegalDungeonFormatException\r\n     */\r\n    Item(Scanner s) throws NoItemException,\r\n        Dungeon.IllegalDungeonFormatException {\r\n\r\n        messages = new Hashtable<String,String>();\r\n\r\n        // Read item name.\r\n        primaryName = s.nextLine();\r\n        if (primaryName.equals(Dungeon.TOP_LEVEL_DELIM)) {\r\n            throw new NoItemException();\r\n        }\r\n\r\n        // Read item weight.\r\n        weight = Integer.valueOf(s.nextLine());\r\n\r\n        // Read and parse verbs lines, as long as there are more.\r\n        String verbLine = s.nextLine();\r\n        while (!verbLine.equals(Dungeon.SECOND_LEVEL_DELIM)) {\r\n            if (verbLine.equals(Dungeon.TOP_LEVEL_DELIM)) {\r\n                throw new Dungeon.IllegalDungeonFormatException(\"No '\" +\r\n                    Dungeon.SECOND_LEVEL_DELIM + \"' after item.\");\r\n            }\r\n            String[] verbParts = verbLine.split(\":\");\r\n            messages.put(verbParts[0],verbParts[1]);\r\n            \r\n            verbLine = s.nextLine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of points that an item gives for picking it up for the first time.\r\n     * @return itemPoints - point value of the item.\r\n     */\r\n    public int getItemPoints(){\r\n    \treturn itemPoints;\r\n    }\r\n    \r\n    /**\r\n     * Checks a given command known as eventName against the hashtable of Events, checks for a result \r\n     * and returns the appropriate message.\r\n     * @param eventName Name to check against hashtable\r\n     * @return String - Details of the event\r\n     */\r\n    public String getEvent(String eventName){\r\n    \treturn null;\r\n    }\r\n    \r\n    boolean goesBy(String name) {\r\n        // could have other aliases\r\n        return this.primaryName.equals(name);\r\n    }\r\n\r\n    String getPrimaryName() { return primaryName; }\r\n\r\n    public String getMessageForVerb(String verb) {\r\n        return messages.get(verb);\r\n    }\r\n\r\n    public String toString() {\r\n        return primaryName;\r\n    }\r\n}\r\n\r\n/**\r\n * Updated to interact with new commands, such as Events and the point system.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n *\r\n */\r\nclass ItemSpecificCommand extends Command {\r\n\r\n    private String verb;\r\n    private String noun;\r\n                        \r\n\r\n    ItemSpecificCommand(String verb, String noun) {\r\n        this.verb = verb;\r\n        this.noun = noun;\r\n    }\r\n\r\n    /**\r\n     * Updated to toss specific actions to trigger events, and interacts with personal hashtables of Item.\r\n     * @return String - Returns string based on action done\r\n     */\r\n    public String execute() {\r\n        \r\n        Item itemReferredTo = null;\r\n        try {\r\n            itemReferredTo = GameState.instance().getItemInVicinityNamed(noun);\r\n        } catch (Item.NoItemException e) {\r\n            return \"There's no \" + noun + \" here.\";\r\n        }\r\n        \r\n        String msg = itemReferredTo.getMessageForVerb(verb);\r\n        return (msg == null ? \r\n            \"Sorry, you can't \" + verb + \" the \" + noun + \".\" : msg) + \"\\n\";\r\n    }\r\n}\r\n\r\n\r\nclass MovementCommand extends Command {\r\n\r\n    private String dir;\r\n                       \r\n\r\n    MovementCommand(String dir) {\r\n        this.dir = dir;\r\n    }\r\n\r\n    public String execute() {\r\n        Room currentRoom = GameState.instance().getAdventurersCurrentRoom();\r\n        Room nextRoom = currentRoom.leaveBy(dir);\r\n        if (nextRoom != null) {  // could try/catch here.\r\n            GameState.instance().setAdventurersCurrentRoom(nextRoom);\r\n            return \"\\n\" + nextRoom.describe() + \"\\n\";\r\n        } else {\r\n            return \"You can't go \" + dir + \".\\n\";\r\n        }\r\n    }\r\n}\r\n\r\nimport java.util.*;\r\n/**\r\n * New Supplementary feature. NPCs can trade items with the player, talk, have their own descriptions and inventory.\r\n * NPCs are placed in certain rooms, and are read from new lines added to the save/bork files.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n *\r\n */\r\npublic class NPC {\r\n\r\n\tprivate String name;\r\n\tprivate String description;\r\n\tprivate ArrayList<Item> Inventory;\r\n\tprivate Hashtable dialogue;\r\n\tprivate Room location;\r\n\t\r\n\t/**\r\n\t * Reads off the npcs and places them in their locations.\r\n\t * @param S Takes a scanner tossed from Room to read off the list of NPCs \r\n\t */\r\n\tNPC(Scanner S){\r\n\t}\r\n\t/**\r\n\t * Removes item from players inventory, and gives it to npc. Vice versa for npc.\r\n\t * @param give Item to be given\r\n\t * @param take Item to be received\r\n\t * @return Item - Gives item to player\r\n\t */\r\n\tItem trade(Item give, Item take){\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Removes item from players inventory and adds it to NPCs\r\n\t * @param gift Item to be given\r\n\t */\r\n\tpublic void give(Item gift){\r\n\t}\r\n\t\r\n\t/**\r\n\t * Takes an item from an npcs inventory and adds it to the players.\r\n\t * @param present item to be taken\r\n\t * @return Item - Item to add to players inventory\r\n\t */\r\n\tItem take(Item present){\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Takes in a String prompt, checks it against hashtable of npc dialogue, returns a String\r\n\t * based on result of hashtable for what to say.\r\n\t * @param prompt String to be checked against\r\n\t * @return String - response to prompt\r\n\t */\r\n\tString talk(String prompt){\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Describes an npc\r\n\t * @return String - description of npc\r\n\t */\r\n\tpublic String describe(){\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the name of an npc\r\n\t * @return String - name of npc\r\n\t */\r\n\tString getName(){\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Sets the description of an npc\r\n\t * @param desc description of npc\r\n\t */\r\n\tvoid setDesc(String desc){\r\n\t}\r\n\t\r\n\t/**\r\n\t * Adds npc line to save file, including inventory, location, status.\r\n\t */\r\n\tpublic void storeState(){\r\n\t}\r\n}\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n/**\r\n * Updated to have point values for rooms, and to read additional lines in the bork/save files.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n *\r\n */\r\npublic class Room {\r\n\r\n    class NoRoomException extends Exception {}\r\n\r\n    static String CONTENTS_STARTER = \"Contents: \";\r\n\r\n    private String title;\r\n    private String desc;\r\n    private boolean beenHere;\r\n    private ArrayList<Item> contents;\r\n    private ArrayList<Exit> exits;\r\n    private int roomPoints;\r\n    private Hashtable npcs;\r\n    \r\n    Room(String title) {\r\n        init();\r\n        this.title = title;\r\n    }\r\n\r\n    /**\r\n     * Returns the local variable roomPoints.\r\n     * @return roomPoints - the value of discovering the room for the first time.\r\n     */\r\n    public int getRooomPoints(){\r\n    \treturn roomPoints;\r\n    }\r\n    \r\n    /**\r\n     * Updated to read from new files. Now reads an additional line in the bork file the lists\r\n     * the NPCs in each room, and places those NPCs in a hashtable in the room.\r\n     * @param s\r\n     * @param d\r\n     * @throws NoRoomException\r\n     * @throws Dungeon.IllegalDungeonFormatException\r\n     */\r\n    Room(Scanner s, Dungeon d) throws NoRoomException,\r\n        Dungeon.IllegalDungeonFormatException {\r\n\r\n        this(s, d, true);\r\n    }\r\n\r\n    /** Given a Scanner object positioned at the beginning of a \"room\" file\r\n        entry, read and return a Room object representing it. \r\n        @param d The containing {@link edu.umw.stephen.bork.Dungeon} object, \r\n        necessary to retrieve {@link edu.umw.stephen.bork.Item} objects.\r\n        @param initState should items listed for this room be added to it?\r\n        @throws NoRoomException The reader object is not positioned at the\r\n        start of a room entry. A side effect of this is the reader's cursor\r\n        is now positioned one line past where it was.\r\n        @throws IllegalDungeonFormatException A structural problem with the\r\n        dungeon file itself, detected when trying to read this room.\r\n     */\r\n    Room(Scanner s, Dungeon d, boolean initState) throws NoRoomException,\r\n        Dungeon.IllegalDungeonFormatException {\r\n\r\n        init();\r\n        title = s.nextLine();\r\n        desc = \"\";\r\n        if (title.equals(Dungeon.TOP_LEVEL_DELIM)) {\r\n            throw new NoRoomException();\r\n        }\r\n        \r\n        String lineOfDesc = s.nextLine();\r\n        while (!lineOfDesc.equals(Dungeon.SECOND_LEVEL_DELIM) &&\r\n               !lineOfDesc.equals(Dungeon.TOP_LEVEL_DELIM)) {\r\n\r\n            if (lineOfDesc.startsWith(CONTENTS_STARTER)) {\r\n                String itemsList = lineOfDesc.substring(CONTENTS_STARTER.length());\r\n                String[] itemNames = itemsList.split(\",\");\r\n                for (String itemName : itemNames) {\r\n                    try {\r\n                        if (initState) {\r\n                            add(d.getItem(itemName));\r\n                        }\r\n                    } catch (Item.NoItemException e) {\r\n                        throw new Dungeon.IllegalDungeonFormatException(\r\n                            \"No such item '\" + itemName + \"'\");\r\n                    }\r\n                }\r\n            } else {\r\n                desc += lineOfDesc + \"\\n\";\r\n            }\r\n            lineOfDesc = s.nextLine();\r\n        }\r\n\r\n        // throw away delimiter\r\n        if (!lineOfDesc.equals(Dungeon.SECOND_LEVEL_DELIM)) {\r\n            throw new Dungeon.IllegalDungeonFormatException(\"No '\" +\r\n                Dungeon.SECOND_LEVEL_DELIM + \"' after room.\");\r\n        }\r\n    }\r\n\r\n    // Common object initialization tasks.\r\n    private void init() {\r\n        contents = new ArrayList<Item>();\r\n        exits = new ArrayList<Exit>();\r\n        beenHere = false;\r\n    }\r\n\r\n    String getTitle() { return title; }\r\n\r\n    void setDesc(String desc) { this.desc = desc; }\r\n\r\n    /*\r\n     * Store the current (changeable) state of this room to the writer\r\n     * passed.\r\n     */\r\n    void storeState(PrintWriter w) throws IOException {\r\n        w.println(title + \":\");\r\n        w.println(\"beenHere=\" + beenHere);\r\n        if (contents.size() > 0) {\r\n            w.print(CONTENTS_STARTER);\r\n            for (int i=0; i<contents.size()-1; i++) {\r\n                w.print(contents.get(i).getPrimaryName() + \",\");\r\n            }\r\n            w.println(contents.get(contents.size()-1).getPrimaryName());\r\n        }\r\n        w.println(Dungeon.SECOND_LEVEL_DELIM);\r\n    }\r\n\r\n    void restoreState(Scanner s, Dungeon d) throws \r\n        GameState.IllegalSaveFormatException {\r\n\r\n        String line = s.nextLine();\r\n        if (!line.startsWith(\"beenHere\")) {\r\n            throw new GameState.IllegalSaveFormatException(\"No beenHere.\");\r\n        }\r\n        beenHere = Boolean.valueOf(line.substring(line.indexOf(\"=\")+1));\r\n\r\n        line = s.nextLine();\r\n        if (line.startsWith(CONTENTS_STARTER)) {\r\n            String itemsList = line.substring(CONTENTS_STARTER.length());\r\n            String[] itemNames = itemsList.split(\",\");\r\n            for (String itemName : itemNames) {\r\n                try {\r\n                    add(d.getItem(itemName));\r\n                } catch (Item.NoItemException e) {\r\n                    throw new GameState.IllegalSaveFormatException(\r\n                        \"No such item '\" + itemName + \"'\");\r\n                }\r\n            }\r\n            s.nextLine();  // Consume \"---\".\r\n        }\r\n    }\r\n\r\n    public String describe() {\r\n        String description;\r\n        if (beenHere) {\r\n            description = title;\r\n        } else {\r\n            description = title + \"\\n\" + desc;\r\n        }\r\n        for (Item item : contents) {\r\n            description += \"\\nThere is a \" + item.getPrimaryName() + \" here.\";\r\n        }\r\n        if (contents.size() > 0) { description += \"\\n\"; }\r\n        if (!beenHere) {\r\n            for (Exit exit : exits) {\r\n                description += \"\\n\" + exit.describe();\r\n            }\r\n        }\r\n        beenHere = true;\r\n        return description;\r\n    }\r\n    \r\n    public Room leaveBy(String dir) {\r\n        for (Exit exit : exits) {\r\n            if (exit.getDir().equals(dir)) {\r\n                return exit.getDest();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    void addExit(Exit exit) {\r\n        exits.add(exit);\r\n    }\r\n\r\n    void add(Item item) {\r\n        contents.add(item);\r\n    }\r\n\r\n    void remove(Item item) {\r\n        contents.remove(item);\r\n    }\r\n\r\n    Item getItemNamed(String name) throws Item.NoItemException {\r\n        for (Item item : contents) {\r\n            if (item.goesBy(name)) {\r\n                return item;\r\n            }\r\n        }\r\n        throw new Item.NoItemException();\r\n    }\r\n\r\n    ArrayList<Item> getContents() {\r\n        return contents;\r\n    }\r\n}\r\n\r\nclass SaveCommand extends Command {\r\n\r\n    private static String DEFAULT_SAVE_FILENAME = \"bork\";\r\n\r\n    private String saveFilename;\r\n\r\n    SaveCommand(String saveFilename) {\r\n        if (saveFilename == null || saveFilename.length() == 0) {\r\n            this.saveFilename = DEFAULT_SAVE_FILENAME;\r\n        } else {\r\n            this.saveFilename = saveFilename;\r\n        }\r\n    }\r\n\r\n    public String execute() {\r\n        try {\r\n            GameState.instance().store(saveFilename);\r\n            return \"Data saved to \" + saveFilename +\r\n                GameState.SAVE_FILE_EXTENSION + \".\\n\";\r\n        } catch (Exception e) {\r\n            System.err.println(\"Couldn't save!\");\r\n            e.printStackTrace();\r\n            return \"\";\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Tallys up given points for an action and adds them to the score in GameState. Points can come from items, actions, etc.\r\n * ScoreCommand is called after other commands.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n *\r\n */\r\npublic class ScoreCommand extends Command{\r\n\t\r\n\tpublic ScoreCommand(){\r\n\t}\r\n\t\r\n\t/**\r\n\t * Runs after another command, if the command gives points, and adds the respective points,\r\n\t * then returns the number of points to be printed.\r\n\t * @return String - Returns string to be printed. Displays points obtained from an action.\r\n\t */\r\n\tpublic String execute() {\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n\r\nclass TakeCommand extends Command {\r\n\r\n    private String itemName;\r\n\r\n    TakeCommand(String itemName) {\r\n        this.itemName = itemName;\r\n    }\r\n\r\n    public String execute() {\r\n        if (itemName == null || itemName.trim().length() == 0) {\r\n            return \"Take what?\\n\";\r\n        }\r\n        try {\r\n            Room currentRoom = \r\n                GameState.instance().getAdventurersCurrentRoom();\r\n            Item theItem = currentRoom.getItemNamed(itemName);\r\n            GameState.instance().addToInventory(theItem);\r\n            currentRoom.remove(theItem);\r\n            return itemName + \" taken.\\n\";\r\n        } catch (Item.NoItemException e) {\r\n            // Check and see if we have this already. If no exception is\r\n            // thrown from the line below, then we do.\r\n            try {\r\n                GameState.instance().getItemFromInventoryNamed(itemName);\r\n                return \"You already have the \" + itemName + \".\\n\";\r\n            } catch (Item.NoItemException e2) {\r\n                return \"There's no \" + itemName + \" here.\\n\";\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Allows a player to talk to an NPC, giving different dialogue based on Player input.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n */\r\npublic class TalkCommand extends Command{\r\n\r\n\tprivate String prompt;\r\n\t\r\n\t/**\r\n\t * Stores variables for execute\r\n\t * @param p String inputed by player\r\n\t */\r\n\tpublic TalkCommand(String p){\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns String by checking player inputed String against a hashtable of NPC dialogue options\r\n\t * @return String - Returns string based on dialogue hashtable\r\n\t */\r\n\tpublic String execute() {\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Trades an item from a player to an NPC, or vice versa, adding the item to their respective inventories.\r\n * @author David, Ryan, Scott\r\n * @version Group Project 2\r\n */\r\npublic class TradeCommand extends Command {\r\n\r\n\tprivate Item give;\r\n\tprivate Item take;\r\n\t\r\n\t/**\r\n\t * Sets up variables for execute method.\r\n\t * @param give Item to be given\r\n\t * @param take Item to be taken\r\n\t * @param npc NPC to interact with\r\n\t */\r\n\tpublic TradeCommand(String give, String take, String npc){\r\n\t}\r\n\t\r\n\t/**\r\n\t * Trades item from user to NPC or vice versa, then returns String to be printed.\r\n\t * @Override execute() \r\n\t * @return String - Prints string to display action to User\r\n\t */\r\n\tpublic String execute() {\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n\r\nclass UnknownCommand extends Command {\r\n\r\n    private String bogusCommand;\r\n\r\n    UnknownCommand(String bogusCommand) {\r\n        this.bogusCommand = bogusCommand;\r\n    }\r\n\r\n    String execute() {\r\n        return \"I'm not sure what you mean by \\\"\" + bogusCommand + \"\\\".\\n\";\r\n    }\r\n}\r\n\r\n/**\r\n * Unlocks a locked exit state. Transforms exit boolean from false to true, allowing the user\r\n * to access the exit.\r\n * @author Scott, David, Ryan\r\n * @version Group Project 2\r\n * \r\n */\r\npublic class UnlockCommand extends Command {\r\n\r\n\tprivate String key;\r\n\t\r\n\t/**\r\n\t * Takes the key to be checked against an Hashtable of keys that an Exit has.\r\n\t * @param key String value to check against hashtable\r\n\t */\r\n\tpublic UnlockCommand(String key){\r\n\t}\r\n\t\r\n\t/**\r\n\t * Executes command and then returns String to be printed stating which door's unlocked.\r\n\t * @Override Command\r\n\t * @return String  to be printed to User\r\n\t */\r\n\tpublic String execute() {\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}